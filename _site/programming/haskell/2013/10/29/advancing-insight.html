<!DOCTYPE html>

<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<title>(Slow but certain) Advancing insight in Haskell</title>
		<meta name="viewport" content="width=device-width">

		<!-- syntax highlighting CSS -->
		<link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css">

		<link href="https://fonts.googleapis.com/css?family=PT+Sans" rel="stylesheet" type="text/css">
		<link href="https://fonts.googleapis.com/css?family=Arvo" rel="stylesheet" type="text/css">
		<link href="/css/default.css" rel="stylesheet">


		<!-- Custom CSS -->
		<script>
			(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
					(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
				m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
			})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

			ga('create', 'UA-42128858-3', 'stmu.co');
			ga('send', 'pageview');

		</script>
	</head>
	<body>
		<nav class="navbar navbar-default navbar-fixed-top">
		<div class="container">
			<div class="navbar-header">
				<button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
					<span class="sr-only">Toggle navigation</span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
				<a class="navbar-brand" href="https://stmu.co">stmu.co</a>
			</div>
			<div id="navbar" class="navbar-collapse collapse">
				<ul class="nav navbar-nav navbar-right">
					<li><a href="mailto:stijn@stmu.co">Contact</a></li>
				</ul>
			</div><!--/.nav-collapse -->
		</div>
		</nav>


		<div class="container">
			<div class="site">

				<h2>(Slow but certain) Advancing insight in Haskell</h2>
<p class="meta">29 Oct 2013</p>

<div class="post">
<p>TL;DR I tried to implement something in Haskell but had some trouble.
I then went to hang out at the Haskell irc channel and they directed me towards a better implementation, making me a little bit smarter.</p>

<p>I am in the process of learning Haskell.
Coming from iterative languages, thinking in a functional way is quite challenging.
Recently, I encountered a situation where I had trouble finding an elegant solution.
I mucked around for a bit and after I found something that worked somewhat, I headed over to the Haskell irc channel where the great folks directed me to a much better solution.</p>

<p>I am a basketball fan and I had written a small <em>play-by-play</em> parser using Parsec.
The outcome of this parser gave an overview of actions that happened in the game, such as “PlayerX” grabbed a rebound, “PlayerY” missed a shot.
Satisfied with my little experiment using Parsec, I then wanted to aggregate these actions and arrive at a traditional <em>box-score</em>.
The parser output and needed data-types look as follows:</p>

<pre><code>data Event = Action String ActionType deriving (Show)
data ActionType = MissedShot
                | MadeShot
                | Rebound
                deriving (Show)

output = [Action "PlayerA" MissedShot, Action "PlayerB" Rebound, Action "PlayerB" MadeShot, ...]
</code></pre>

<p>The new output should be a list of players with aggregated stats, so I created (after learning about Data.Map) a player data type as follows:</p>

<pre><code>import qualified Data.Map as M
data Player = Player Int Int Int deriving (Show)
--- integers stand for: made shots, missed shots, rebounds
type Players = M.map String Player
</code></pre>

<p>In my first attempt, I defined functions to add shots and rebounds.
I then defined a function that takes the list of events together with the existing players and updates these existing players with each event.
It looked as follows:</p>

<pre><code>addRebound :: Maybe Player -&gt; Player
addRebound (Just (Player made missed rebound)) = Player made missed (rebound + 1)
addRebound Nothing = Player 0 0 1 

addMadeShot :: Maybe Player -&gt; Player
addMadeShot (Just (Player made missed rebound)) = Player (made + 1) missed rebound
addMadeShot Nothing = Player 1 0 0 

addMissedShot :: Maybe Player -&gt; Player
addMissedShot (Just (Player made missed rebound)) = Player made (missed + 1) rebound
addMissedShot Nothing = Player 0 1 0

aggregate :: [Event] -&gt; Players -&gt; Players
aggregate [] p = p 
aggregate ((Action name MadeShot):rest) players = aggregate rest (M.insert name (addMadeShot (M.lookup name players)) players)
aggregate ((Action name MissedShot):rest) players = aggregate rest (M.insert name (addMissedShot (M.lookup name players)) players)
aggregate ((Action name Rebound):rest) players = aggregate rest (M.insert name (addRebound (M.lookup name players)) players)

-- hint, you can run this piece of code in ghci as follows:
-- $ :load filename
-- $ import Data.Map as M
-- $ aggregate output M.empty
</code></pre>

<p>The iterative tendencies are easily spotted, those add… methods are simply record updates.
It is clear that this approach is neither elegant or “haskelly”.
When one would want to account for extra actions, such as steals for example, a new method would have to be added as well and the “aggregate” function would have to be able to recognise that new category.</p>

<p>The folks on irc advised me to look at the Player data type with a different mindset.
Instead of updating fields, players should be added together.
There should be a “zeroPlayer”, with all fields initialised to 0.
There should also be a “reboundPlayer”, a player with 1 rebound.
Similar for the “madeShotPlayer” and “missedShotPlayer”.
By defining these players and a generic player addition function, the different add… methods can be eliminated.
I also changed my parser slightly so the actions are of type <code>Action String Player</code> and I used the “record” syntax for data type definition.</p>

<pre><code>import qualified Data.Map as M
data Player = Player { madeShot :: Int, missedShot :: Int, rebound :: Int} deriving (Show)
data Event= Action String Player deriving (Show)

type Players = M.Map Name Player

addPlayer :: Player -&gt; Player -&gt; Player
addPlayer (Player a1 a2 a3) (Player b1 b2 b3) = Player (a1+b1) (a2+b2) (a3+b3)

zeroPlayer = Player 0 0 0
madeShotPlayer = zeroPlayer {madeShot = 1}
missedShotPlayer = zeroPlayer {missedShot = 1}
reboundPlayer = zeroPlayer {rebound=1}

aggregate :: [Event] -&gt; Players -&gt; Players
aggregate [] p = p
aggregate ((Action name p):rest) players = aggregate rest (M.insertWith (addPlayer) name players)

output = [Action "playera" madeShotPlayer, Action "playerb" missedShotPlayer, Action "playera" madeShotPlayer]
</code></pre>

<p>When writing the above piece of code, it seemed as if the language was working with me instead of against me, definitely a good sign!
The next steps include using “folding” in the aggregate function and maybe using a map to hold the different statistic categories in the player data type.</p>

<p>Would you write this piece of code differently? Let me know in the comments!</p>

</div>

				<br>
				<hr>
				<div class="well green-background" id="subscriber-fields">
					<p>If you have read this far, consider subscribing for updates:</p>
					<form action="https://stmu.us7.list-manage.com/subscribe/post?u=c6f5e277d8416e9f9463f7df2&amp;id=c434e81608" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="form-inline" role="form" target="_blank" novalidate>
						<div class="form-group">
							<input type="email" value="" name="EMAIL" class="form-control" id="mce-EMAIL" placeholder="email address" required>
						</div>
						<button type="submit" name="subscribe" id="mc-embedded-subscribe" class="btn btn-warning">Subscribe</button>
					</form>
				</div>
				<img src="https://www.linkedin.com/in/stijnmuylle" width="1" height="1">
				<div id="disqus_thread"></div>
				<script type="text/javascript">
					/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
				var disqus_shortname = 'stmu'; // required: replace example with your forum shortname

				/* * * DON'T EDIT BELOW THIS LINE * * */
				(function() {
				 var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				 dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
				 (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				 })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

<div class="footer">
	<div class="contact">
		<p>
		stijn@stmu.co<br />
		</p>
	</div>
</div>
	  </div>
  </div> <!-- /container -->

    </body>
</html>
