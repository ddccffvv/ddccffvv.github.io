<!DOCTYPE html>

<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Opportunities to use monoids</title>
        <meta name="viewport" content="width=device-width">

        <!-- syntax highlighting CSS -->
        <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap.min.css">

        <link href="https://fonts.googleapis.com/css?family=PT+Sans" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Arvo" rel="stylesheet" type="text/css">
        <link href="/css/default.css" rel="stylesheet">


        <!-- Custom CSS -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42128858-3', 'stmu.co');
  ga('send', 'pageview');

</script>
    </head>
    <body>

        <div class="container">
          <div class="site">
            <div class="header">
              <h1 class="title"><a href="/">stmu</a> </h1>
              <a class="extra" href="/">home</a>
              <a class="extra" href="mailto:stijn@stmu.co">contact</a>
            </div>

                <h2>Opportunities to use monoids</h2>
<p class="meta">17 Feb 2014</p>

<div class="post">
<p>Recently, I was watching <a href="http://www.youtube.com/watch?v=cMY1KVrJk0w">this talk</a> by Avi Bryant where he talks about using algebra in programming. The talk is geared towards distributed systems, but I think the concepts are applicable in general. Certainly when I realised that my earlier <a href="http://stmu.co/programming/haskell/2013/10/29/advancing-insight.html">trouble</a> also concerned monoids.. So, what’s to gain from understanding this algebra? At least improved code reusability and parallelism. And an opportunity to satisfy your curiosity!</p>

<p>As always, any suggestions or remarks are welcomed!</p>

<h2 id="what_is_a_monoid">What is a monoid?</h2>

<p>A <a href="http://en.wikipedia.org/wiki/Monoid">monoid</a> is an algabraic structure. It exists of a Set and an operation on that set (when A and B are elements of a set, A <em>operation</em> B yields C which is also an element of the set). The following conditions must hold:</p>

<ul>
<li><em>Associativity</em>: (a <em>operation</em> b) <em>operation</em> c == a <em>operation</em> (b <em>operation</em> c)</li>

<li><em>Identity Element</em>: identity <em>operation</em> a == a == a <em>operation</em> identity</li>
</ul>

<p>You can think of many monoids yourself. For example: the set of integers, the + operation and identity element 0. Or another example: the set of all possible strings, the concat operation and an empty string as identity element.</p>

<h2 id="why_will_this_be_useful">Why will this be useful?</h2>

<p>Above, I talked about code reusability and parallelism. Let’s start with parallelism.</p>

<p>To get started, we’ll use the following monoid: Set = integers; Operation = +; Identity = 0. Let’s assume for a moment that + is a very difficult operation and it takes a computer an hour to calculate the result. When asked to add integers 1 through 6, it is natural to solve the problem in the following way:</p>

<pre><code>(((((((1 + 2) + 3) + 4) + 5) + 6) + 7) + 8)</code></pre>

<p>If we use this method, we would have the result in 7 hours. Could we do it faster? Especially when we have multiple computers? Well yes, just solve the problem in the following way:</p>

<pre><code>(1 + 2) + (3 + 4) + (5 + 6) + (7 + 8)
(3      +  7    ) + (11   ) + (15   )
(      10       ) + (     26        )
(                36                 )</code></pre>

<p>The same calculation now takes 4 hours (but uses 4 computers, a nice trade-off if we have a lot of computers and a lack of time). The advantage lies in the fact that adding is inherently parallel. It doesn’t matter if you start to add at the beginning, the end or in the middle, the end result is always the same. This parallelism stems from the associativity property, which you get with every monoid!</p>

<p>Now, how about code reusability? To understand this you have to think about the fundamental concepts of the monoid. There has to be a set, an operation and an identity method. Even when you don’t know which monoid you are working with, the method of solving is always the same: take 2 elements as input, apply the operation and receive 1 element as output. Repeat until only one element is left. Because this method is always the same, you can just reuse it and plug different monoids in as needed. Still fuzzy? Have a look at the examples.</p>

<h2 id="examples">Examples</h2>

<p>I’m importing these libraries everywhere.</p>

<pre><code>import Data.Monoid
import Data.List.Split</code></pre>

<p>The sum example described in the previous section:</p>

<pre><code>-- summing
-- some data to work with
sum_data =  [AdditionTest c | c &lt;- [1..]]

-- define a type to work with. Does anybody know if you can also define a monoid on Int?
data AdditionTest = AdditionTest Int deriving (Show)

-- define the monoid, addTest is the operation
instance Monoid AdditionTest where
    mempty = AdditionTest 0
    mappend = addTest

addTest :: AdditionTest -&gt; AdditionTest -&gt; AdditionTest
addTest (AdditionTest x) (AdditionTest y) = AdditionTest (x+y)

-- when a monoid is defined on a certain type, mappend points to its operation and mempty to the identity element
-- foldl takes a list and applies an operation on it from left to right (with given start element)
-- in this case, the operation is mappend and the start element is mempty
sum_result = foldl mappend mempty $ take 100 sum_data

-- doesn&#39;t matter if starting left or right...
sum_result&#39; = foldr mappend mempty $ take 100 sum_data

-- or even different chunks and then combine the chunks...
chunks = chunksOf 10 $ take 100 sum_data
sum_result&#39;&#39; = foldr mappend mempty $ map (foldr mappend mempty) chunks</code></pre>

<p>Let’s generalise our calculation method. We’ll define a new aggregation function that just takes a list and applies the mappend function on the elements. The start element will again be mempty:</p>

<pre><code>aggregate x = foldl mappend mempty x

-- example of the general function with sum
sum_result&#39;&#39;&#39; = aggregate $ take 100 sum_data</code></pre>

<p>Now, we’ll be able to use the <code>aggregate</code> function for different monoids. For example, can we aggregate strings?</p>

<pre><code>--defining some data to work with
string_data = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;j&quot;, &quot;k&quot;, &quot;l&quot;]

--a new type and corresponding monoid
data StringAddition = StringAddition String deriving (Show)
instance Monoid StringAddition where
    mempty = StringAddition &quot;&quot;
    mappend = stringAppend

--the mappend operation
stringAppend (StringAddition x) (StringAddition y) = StringAddition (x ++ y)

--reusing the aggregate function
sum_string = aggregate string_data</code></pre>

<p>That was easy! How about finding a maximum?</p>

<p>Apropos, does anybody know how to define a Monoid on all classes that derive Ordering? There is probably a problem with chosing a sane mempty, because ord doesn’t seem to have that?</p>

<p>Apropos2, is it possible to define 2 monoids for the same data type? For example: an Int monoid for sum and one for product.</p>

<pre><code>--same drill: defining type, data and monoid
data MaxTest = MaxTest Int deriving (Show)
max_data =  [MaxTest c | c &lt;- [1..]]

instance Monoid MaxTest where
    mempty = MaxTest 0
    mappend = maxTest

maxTest (MaxTest x) (MaxTest y) = MaxTest $ max x y

max_result = aggregate $take 100 max_data</code></pre>

<p>Averages? This one is a bit different, we cannot just add averages together. Instead, we just store the sum of all numbers and the amount of numbers we processed. The average can then be calculated by doing sum/occurences.</p>

<pre><code>data AverageData = AverageData { sum:: Int, occurences :: Int }  deriving (Show)

average_data = [(AverageData 2 3), (AverageData 2 5)]

instance Monoid AverageData where
    mempty = AverageData 0 0
    mappend = averageAggregate

averageAggregate :: AverageData -&gt; AverageData -&gt; AverageData
averageAggregate (AverageData a b) (AverageData x y) = AverageData (a+x) (b+y)

average_result = aggregate average_data</code></pre>

<p>Next steps? Well, there is still a lot to learn:</p>

<ul>
<li><a href="https://speakerdeck.com/johnynek/algebra-for-analytics">Algebra for Analytics</a></li>

<li><a href="http://en.wikipedia.org/wiki/Bloom_filter">Bloom filters</a></li>

<li><a href="http://blog.aggregateknowledge.com/2012/10/25/sketch-of-the-day-hyperloglog-cornerstone-of-a-big-data-infrastructure/">HyperLogLog</a></li>
</ul>

<p>What do you think? Suggestions and remarks are welcomed!</p>

<h3 id="update">Update</h3>

<p><a href="http://www.reddit.com/r/haskell/comments/1yc2vg/opportunities_to_use_monoids/cfjads2">This</a> comment on Reddit by mstksg points out that monoids already have an <code>aggregate</code> function built in. <code>mconcat</code> is defined as <code>foldr mappend mempty</code>, almost exactly as I did.</p>
</div>

                <br>
                <hr>
<div class="well" id="subscriber-fields">
    <p>If you have read this far, consider subscribing for updates:</p>
<form action="https://stmu.us7.list-manage.com/subscribe/post?u=c6f5e277d8416e9f9463f7df2&amp;id=c434e81608" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="form-inline" role="form" target="_blank" novalidate>
    <div class="form-group">
<input type="email" value="" name="EMAIL" class="form-control" id="mce-EMAIL" placeholder="email address" required>
</div>
<button type="submit" name="subscribe" id="mc-embedded-subscribe" class="btn btn-success">Subscribe</button>
</form>
</div>
<img src="https://www.linkedin.com/in/stijnmuylle" width="1" height="1">
<div id="disqus_thread"></div>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'stmu'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    <a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    
            <div class="footer">
              <div class="contact">
                <p>
                  stijn@stmu.co<br />
                </p>
              </div>
            </div>
          </div>
        </div> <!-- /container -->

    </body>
</html>
